@startuml
!include style.puml
skinparam arrowColor #BLACK
skinparam noteTextAlignment left


Participant "<<Class>>\nParser" as Parser LOGIC_COLOR
Participant "<<Class>>\nParserUtility" as UParser LOGIC_COLOR_T1

[-> Parser : parseCommandType(userInput:String)
activate Parser
Parser -->[ : keywordString:String
deactivate Parser

loop LOOP_COLOR for each XYZ term in command
    note right : XYZ is a placeholder for the terms required for a command \n\
    e.g. NAME or GROUP_INDEX for an **add** command.

    [-> Parser : parseXYZ(userInput:String)
    activate Parser

    note right : XYZ in the methods are replaced accordingly \n\
    e.g. parseName or parseGroupIndex

    ' checkContainsOnlyOneDelimiter
    Parser -> UParser : checkContainsOnlyOneDelimiter(userInput:String, delimiterXYZ:String)
    activate UParser
    opt OPT_COLOR found no delimiterXYZ
        UParser --> Parser : :MissingDelimiterException
        Parser -->[ : :MissingDelimiterException
    else found too many delimiterXYZ
        UParser --> Parser : :DuplicateDelimiterException
        Parser -->[ : :DuplicateDelimiterException
    end opt
    UParser --> Parser
    deactivate UParser

    ' parseDelimitedTerm
    Parser -> UParser : parseDelimitedTerm(userInput:String, delimiterXYZ:String)
    activate UParser
    opt OPT_COLOR XYZ.isBlank()
        UParser --> Parser : :EmptyStringException
        Parser -->[ : :EmptyStringException
    end opt
    UParser --> Parser : //XYZ//:object
    deactivate UParser

    Parser -->[ : //XYZ//:object
    deactivate Parser

    ' needs Validation
    opt OPT_COLOR_T1 if //XYZ// needs validation checking
        [-> Parser : getValidXYZ(//XYZ//:String, [maxValue:int])
        note right : [maxValue:int] is only needed if //XYZ// is not Money
        activate Parser

        ' isMoney?
        alt //XYZ// is Money

            opt OPT_COLOR //XYZ// is not a double
                Parser -->[ : :InvalidMoneyException
            end opt

            ' checkNegative
            Parser -> UParser : checkNegativeMoney(//XYZ//:double)
            activate UParser
            opt OPT_COLOR //XYZ// is negative
                UParser --> Parser : :NumberFormatException
                Parser -->[ :InvalidMoneyException
            end opt
            UParser --> Parser
            deactivate UParser

            Parser -->[ : //XYZ//:double

        ' notMoney
        else //XYZ// is not Money

            opt OPT_COLOR //XYZ// is an integer
                Parser -->[ : :InvalidIndexException
            end opt

            ' checkTooHigh
            Parser -> UParser : checkTooHighIndex(//XYZ//:int, maxValue:int)
            activate UParser
            opt OPT_COLOR //XYZ// > maxValue
                UParser --> Parser : :IndexOutOfBoundsException
                Parser -->[ :InvalidIndexException
            end opt
            UParser --> Parser
            deactivate UParser

            ' checkTooLow
            Parser -> UParser : checkTooLowIndex(//XYZ//:int, 1:int)
            activate UParser
            opt OPT_COLOR //XYZ// < 1 //(MIN_INDEX)//
                UParser --> Parser : :IndexOutOfBoundsException
                Parser -->[ :InvalidIndexException
            end opt
            UParser --> Parser
            deactivate UParser

            Parser -->[ : //XYZ//:int
            deactivate Parser
        end opt
    end opt

end loop

@enduml

